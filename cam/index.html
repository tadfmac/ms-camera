<!DOCTYPE html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>camera</title>
<style>
*{
  margin: 0px;
  padding: 0px;
  box-sizing: border-box;
}
.wTitle{
  display: flex;
  justify-content:space-between
  width: 100%;
  background-color: pink;
  padding: 2px 10px;
}
#mTitle{
  width: 80%;
}
#connection_status{
  top: 2px;
  right: 10px;
  position: fixed;
  text-align: right;
  width: 200px;
}
</style>
</head>
<body>
<div class="wTitle">
  <div id="mTitle">ms-camera sender</div>
  <div id="connection_status"></div>
</div>
<div id="wVideo"></div>
<script type="module">
import socketClient from "../lib/socketio-client-esm.js";
import config from '../lib/config.json' assert {type:"json"};
import msclient from '../lib/ms-client.mjs';

const hostname = window.location.hostname;

let socket;
let stream;
let msc;
let cams;

const $txtConnection = document.querySelector('#connection_status');
const $wVideo = document.querySelector('#wVideo');

(async ()=>{
  await init();
  await startCam();
})();

async function init() {
  $txtConnection.innerHTML = 'Connecting...';

  const opts = {
    path: '/server',
    transports: ['websocket'],
  };

  const serverUrl = `https://${hostname}:${config.listenPort}`;
  socket = socketClient(serverUrl, opts);

  msc = new msclient(socket,config);
  await msc.init("caster");

  socket.on('connect', async () => {
    $txtConnection.innerHTML = 'Connected';
  });

  socket.on('disconnect', () => {
    $txtConnection.innerHTML = 'Disconnected';
  });

  socket.on('connect_error', (error) => {
    console.error('could not connect to %s%s (%s)', serverUrl, opts.path, error.message);
    $txtConnection.innerHTML = 'Connection failed';
  });
}

async function startCam(e) {
  try {
    let cams = await getDeviceCams();
    $wVideo.innerHTML = "";
    for(let cnt=0;cnt<cams.length;cnt++){
      let params = {
        video: {
          deviceId: cams[cnt].deviceId,
          width: { min: 640, ideal: 1280, max: 1920 }
        }
      };
      cams[cnt].stream = await navigator.mediaDevices.getUserMedia(params);
      cams[cnt].producer = await msc.produceCam(cams[cnt].stream,cams[cnt].camName);
      const $video = document.createElement("video");
      $video.muted = true;
      $video.srcObject = cams[cnt].stream;
      $video.playsInline = true;
      $wVideo.appendChild($video);
      await $video.play();
    }
  } catch (err) {
    console.log("start() err : "+err);
    $txtConnection.innerHTML = 'startCam() failed : '+err;
  }
}

async function getDeviceCams(){
  cams = [];
  let devices = await navigator.mediaDevices.enumerateDevices();
  if(devices){
    for(let cnt=0;cnt<devices.length;cnt++){
      if(devices[cnt].kind != "videoinput"){
        continue;
      }
      let _camName;
      if(devices[cnt].label){
        _camName = devices[cnt].label;
      }else{
        _camName = devices[cnt].deviceId;
      }
      cams.push({deviceId:devices[cnt].deviceId, camName:_camName});
    }
  }
  return cams;
}
</script>
</body>
</html>
